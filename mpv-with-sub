#!/bin/bash

# mpv-with-sub - Bash shell script for mpv's subtitle with episodes

# Copyright 2020, Taeseong Ryu <formeu2s@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

# I wrote this script to play a video for emacs' dired mode in EXWM
# especially for the file with episodes

# this script has the following options
# 1. only one subtitle in the directory (recursive)
# 2. exactly same name with video file
# 3. fuzzy subtitle with video file
# 4. episode subtitle like S01E01
# 5. in terminal, if subtitles exist, you can choose one or all

# it searches a current directory recursively first, if none, searches SUBDIR
# if it fails to find a subtitle, it uses the mpv's original option

# the episode part of a subtitle
#
# S01E01 or S01.E01
# E01
# Series.1.Part.1

## TODO
#



PS3="
# for all, press 00
choose : "
garg=( "$@" )
garg0="$0"
garg1="$1"
garg2="$2"
PROGNAME="${garg0##*/}"
BASH_VERSION='5.0.18(1)-release'
VERSION=0.1
SUBEXT='(srt|smi|ass|sub)'
#
# add another subtitle directory
#
SUBDIRS=( '/mnt/data/Downloads/sub' )
videofile="${garg1##*/}"
videodir="${garg1%$videofile}"
videofileext=${garg1##*.}
videosansname="${videofile%.$videofileext}"
lowername="${videosansname,,}"
EP_PATTERN1='s[0-9]\+\.\?e[0-9]\+'
EP_PATTERN2='e[0-9]\+'
EP_PATTERN3='series\.\?[0-9]\+\.\?part\.\?[0-9]\+'
ep1=$(grep -o "$EP_PATTERN1" <<< $lowername)
ep2=$(grep -o "$EP_PATTERN2" <<< $lowername)
ep3=$(grep -o "$EP_PATTERN3" <<< $lowername)

if [[ -n $ep1 ]] ; then
    ep="$ep1"
elif [[ -n $ep2 ]] ; then
    ep="$ep2"
elif [[ -n $ep3 ]] ; then
    ep="$ep3"
fi



back_trace() {
    local maxlength format1
    for key in "${!FUNCNAME[@]}" ; do
        if (( ${#FUNCNAME[$key]} > ${maxlength:-0} )) ; then
            maxlength=${#FUNCNAME[$key]}
        fi
    done
    format1="\n%-${maxlength}s : %5s"
    # printf "$format1" \
    #        "LINENO" ${LINENO}
    for key in ${!BASH_LINENO[@]} ; do
        printf "$format1" \
               ${FUNCNAME[$key]} ${BASH_LINENO[$key]}
    done
    printf "\n"
}

test_print() {
    local arg1="$1"
    local arg2="$2"
    linesnumber=$(wc -l <<< $arg2)
    printf '\n\e[1;38;5;220m%s\n\e[1;38;5;240m%s\e[0m' \
           "$arg1" "$arg2"
    printf '\n\e[1;38;5;40m%s lines\e[0m\n' \
           $linesnumber
    # back_trace
    return 0
}

grep_print() {
    local arg1="$1"
    printf '\n \e[1;31m%s\e[0m\n\n' \
           "$arg1"
    return 0
}

check() {
    local arg1="$1"
    subcount=0
    for file in $arg1 ; do # error if quote
        filename="${file##*/}"
        lowerfile="${filename,,}"
        filenameext=${lowerfile##*.}
        filesansname="${lowerfile%.$filenameext}"
        if [[ $filenameext =~ $SUBEXT ]] ; then
            ((subcount++))
            subfile="$file"
            if [[ $filesansname == $videosansname ]] ; then
                subtitles1="$file"
                test_print subtitles1 "$subtitles1"
                break
            elif [[ $filesansname =~ $videosansname ]] ; then
                subtitles2+=( "$file" )
                test_print subtitles2 "${subtitles2[-1]}"
            elif [[ -n "$ep" ]] ; then
                if [[ $filesansname =~ $ep|${ep/./}|${ep/e/.e} ]] ; then
                    subtitles3+=( "$file" )
                    test_print subtitles3 "${subtitles3[-1]}"
                elif [[ $filesansname =~ e0*${ep#*e} ]] ; then
                    subtitles4+=( "$file" )
                    test_print subtitles4 "${subtitles4[-1]}"
                elif [[ $filesansname =~ e0*${ep#*part\.} ]] ; then
                    subtitles5+=( "$file" )
                    test_print subtitles5 "${subtitles5[-1]}"
                fi
            fi
        fi
    done
    #
    # only one subtitle > exact > fuzz > s01e01 > e01 > series.1.part.1
    #
    if (( $subcount == 1 )) ; then
        subtitles="$subfile"
    elif [[ -n $subtitles1 ]] ; then
        subtitles="$subtitles1"
    elif [[ -n $subtitles2 ]] ; then
        subtitles=( "${subtitles2[@]}" )
    elif [[ -n $subtitles3 ]] ; then
        subtitles=( "${subtitles3[@]}" )
    elif [[ -n $subtitles4 ]] ; then
        subtitles=( "${subtitles4[@]}" )
    elif [[ -n $subtitles5 ]] ; then
        subtitles=( "${subtitles5[@]}" )
    else
        printf '\n \e[1;31m%s\e[0m\n\n' \
               'No subtitle.'
    fi
    test_print subtitles "${subtitles[@]}"
    return 0
}

_play() {
    #
    # with --sub-files="subtitle1:subtitle2
    #
    local arg1="$1"
    local thesubdir subfiles
    for subdir in "${SUBDIRS[@]}" ; do
        if [[ $arg1 =~ $subdir ]] ;then
            thesubdir="$subdir"
            break
        fi
    done
    for subtitle in "${subtitles[@]}" ; do
        subfiles+="$subtitle"":" # need " "?
    done
    subfiles="${subfiles%:}"
    if [[ $arg1 =~ $thesubdir ]] ; then
        mpv --sub-files="$subfiles" "$garg1"
    else
        mpv --sub-files="$videodir""$subfiles" "$garg1"
    fi
    return 0
}

play() {
    #
    # with array --sub-file="$subtitle1" --sub-file="$subtitle2"
    #
    local arg1="$1"
    local thesubdir subfiles
    for subdir in "${SUBDIRS[@]}" ; do
        if [[ $arg1 =~ $subdir ]] ;then
            thesubdir="$subdir"
            break
        fi
    done
    if [[ $arg1 =~ $thesubdir ]] ;then
        for subtitle in "${subtitles[@]}" ; do
            subfiles+=( --sub-file="$subtitle" )
        done
    else
        for subtitle in "${subtitles[@]}" ; do
            subfiles+=( --sub-file="$videodir""$subtitle" )
        done
    fi
    mpv "${subfiles[@]}" "$garg1"
    return 0
}



if [[ ! -e $garg1 ]] ; then
    printf '\n \e[1;31m%s\e[0m\n\n' \
           'mpv-with-sub requires a file as the first argument.'
    exit 2
fi
test_print episode "$ep"
#
# for recursive directories
# probably need -2 deep level, otherwise so many files will be checked
#
shopt -s globstar
[[ -n $videodir ]] && cd "$videodir"
check "**/*"
if [[ -z $subtitles ]] ; then
    for subdir in "${SUBDIRS[@]}" ; do
        check "$subdir/**/*"
        if [[ -n $subtitles ]] ; then
            break
        fi
    done
fi
#
# when this script runs in terminal, select-loop activates.
# added "--dired" as $2 to distinguish between emacs-dired and terminal
#
if [[ $garg2 != --dired ]] ; then
    if (( ${#subtitles[@]} == 1 )) ; then
        selected="$subtitles"
    elif (( ${#subtitles[@]} > 1 )) ; then
        printf '\n' # needed
        select subtitle in "${subtitles[@]}" ; do
            if [[ $REPLY =~ ^00$ ]] ; then
                printf '\n\n %s\n' \
                'You choose all subtitles.'
                grep_print "${subtitles[@]}"
                play "${subtitles[@]}"
                exit 0
            elif [[ -n $subtitle ]] ; then
                selected="$subtitle"
                break
            else
                printf '\n \e[1;31m%s\e[0m\n' \
                       'Something is wrong!'
                back_trace
                exit 1
            fi
        done
    fi
fi
if [[ -n $selected ]] ; then
    grep_print "$selected"
    subtitles="$selected"
    play "$subtitles"
elif [[ -n $subtitles ]] ; then
    grep_print "${subtitles[@]}"
    play "${subtitles[@]}"
else
    mpv "$garg1"
fi
