#!/bin/bash

# mpv-with-sub - Bash shell script for mpv's subtitle with episodes

# Copyright 2020, Taeseong Ryu <formeu2s@gmail.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License at <http://www.gnu.org/licenses/> for
# more details.

# I wrote this script to play a video for emacs' dired mode in EXWM
# especially for the file with episodes

# this script has the following options
# 1. only one subtitle in the directory (recursive)
# 2. exactly same name with video file
# 3. fuzzy subtitle with video file
# 4. episode subtitle like S01E01
# 5. in terminal, if subtitles exist, you can choose one or all or none

# it searches a current directory recursively first, if none, searches SUBDIR
# if it fails to find a subtitle, it uses the mpv's original option

# the episode part of a subtitle
#
# S01E01 or S01.E01
# E01
# Series.1.Part.1

## TODO
#

if [[ ! -e $1 ]] ; then
    printf "\n"
    printf "\n mpv-with-sub requires a file as the first argument."
    printf "\n"
    exit 2
fi

PS3="
# for all, press 00
# for none, press 0
choose : "
garg=("$@")
garg0="$0"
garg1="$1"
garg2="$2"
PROGNAME=${garg0##*/}
VERSION="0.1"
SUBEXT="(srt|smi|ass|sub)"
SUBDIR="/mnt/data/Downloads/sub"
videofile=${garg1##*/}
videodir=${garg1%"$videofile"}
videofileext=${garg1##*.}
videosansname=${videofile%."$videofileext"}
lowername=${videosansname,,}
PATTERN1="s[0-9]\+\.\?e[0-9]\+"
PATTERN2="e[0-9]\+"
PATTERN3="series\.\?[0-9]\+\.\?part\.\?[0-9]\+"
ep1=$(grep -o "$PATTERN1" <<< "$lowername")
ep2=$(grep -o "$PATTERN2" <<< "$lowername")
ep3=$(grep -o "$PATTERN3" <<< "$lowername")

if [[ -n $ep1 ]] ; then ep="$ep1"
elif [[ -n $ep2 ]] ; then ep="$ep2"
elif [[ -n $ep3 ]] ; then ep="$ep3"
else ep="" ; fi



test_print() {
    local arg1="$1"
    local arg2="$2"
    local linesnumber
    linesnumber=$(wc -l <<< "$arg2")
    if (( linesnumber == 1 )) ; then
        printf "\n\n${arg1} is ${arg2}\n\n"
    elif (( linesnumber > 1 && linesnumber < 10)) ; then
        printf "\n\n${arg1} is \n${arg2}\n\n"
        printf "\n"
    else
        printf "\n\n${arg1} is \n${arg2}\n\n"
        printf "${linesnumber} lines"
        printf "\n"
    fi
    return 0
}

grep_print() {
    local arg1="$1"
    printf "\n"
    grep --color=auto . <<< "$arg1"
    printf "\n"
    return 0
}

check() {
    local arg1="$1"
    subcount=0
    for file in $arg1 ; do # error if quote
        filename=${file##*/}
        lowerfile=${filename,,}
        filenameext=${lowerfile##*.}
        filesansname=${lowerfile%."$filenameext"}
        if [[ $filenameext =~ $SUBEXT ]] ; then
            (( subcount++ ))
            subfile="$file"
            if [[ $filesansname == $videosansname ]] ; then
                subtitles1="$file"
                test_print subtitles1 "$subtitles1"
                break
            elif [[ $filesansname =~ $videosansname ]] ; then
                subtitles2="$file"
                test_print subtitles2 "$subtitles2"
            elif [[ -n "$ep" ]] ; then
                if [[ $filesansname =~ $ep|${ep/./}|${ep/e/.e} ]] ; then
                    if [[ -z $subtitles3 ]] ; then
                        subtitles3="$file"
                    else
                        subtitles3="$subtitles3":"$file"
                    fi
                    test_print subtitles3 "$subtitles3"
                elif [[ $filesansname =~ e0*${ep#*e} ]] ; then
                    if [[ -z $subtitles4 ]] ; then
                        subtitles4="$file"
                    else
                        subtitles4="$subtitles4":"$file"
                    fi
                    test_print subtitles4 "$subtitles4"
                elif [[ $filesansname =~ e0*${ep#*part\.} ]] ; then
                    if [[ -z $subtitles5 ]] ; then
                        subtitles5="$file"
                    else
                        subtitles5="$subtitles5":"$file"
                    fi
                    test_print subtitles5 "$subtitles5"
                # else
                #     printf "\n"
                #     printf "\n No subtitle is here."
                #     printf "\n Trying another source."
                #     printf "\n"
                fi
            fi
        fi
    done

    # only one subtitle > exact > fuzz > s01e01 > e01 > series.1.part.1
    if (( $subcount == 1 )) ; then
        subtitles="$subfile"
    elif [[ -n $subtitles1 ]] ; then subtitles="$subtitles1"
    elif [[ -n $subtitles2 ]] ; then subtitles="$subtitles2"
    elif [[ -n $subtitles3 ]] ; then subtitles="$subtitles3"
    elif [[ -n $subtitles4 ]] ; then subtitles="$subtitles4"
    elif [[ -n $subtitles5 ]] ; then subtitles="$subtitles5"
    else
        printf "\n"
        printf "\n No subtitle."
        printf "\n"
    fi
    test_print subtitles "$subtitles"
    return 0
}

play() {
    local arg1="$1"
    if [[ "$arg1" =~ /mnt/data/Downloads/sub ]] ;then
        mpv --sub-files="$subtitles" "$garg1"
    else
        mpv --sub-files="$videodir""$subtitles" "$garg1"
    fi
    return 0
}



test_print episode "$ep"
[[ -n $videodir ]] && cd "$videodir"

# for recursive directories
# probably need -2 deep level, otherwise so many files will be checked
shopt -s globstar
check "**/*"

if [[ -z "$subtitles" ]] ; then
    check "$SUBDIR/**/*"
fi

# when this script runs in terminal, select-loop activates.
# added "--dired" as $2 to distinguish between emacs-dired and terminal
if [[ $2 != "--dired" ]] ; then
    subtitlelines=$(sed s/:/\\n/g <<< $subtitles)
    test_print subtitlelines "$subtitlelines"
    if (( $(wc -l <<< $subtitlelines) == 1 )) ; then
        selectedsubtitle="$subtitlelines"
    elif (( $(wc -l <<< $subtitlelines) > 1 )) ; then
        printf "\n"
        readarray -t arr_subtitles <<< "$subtitlelines"
        select subtitle in ${arr_subtitles[@]} ; do
            if [[ $REPLY =~ ^00$ ]] ; then
                printf "\n"
                printf "\n You choose all subtitles. They'll be loaded."
                printf "\n To cycle through the available subtitles,"
                printf "\n press j and J."
                grep_print "$subtitles"
                play "$subtitles"
                exit 0
            elif [[ $REPLY =~ ^0$ ]] ; then
                printf "\n"
                printf "\n You choose no subtitle."
                printf "\n It doesn't load any external subtitle."
                printf "\n"
                mpv --sub-auto=no "$1"
                exit 0
            else
                printf "\n"
                printf "\n Sorry, something is wrong!"
                printf "\n Try again."
                printf "\n"
                exit 1
            fi
            selectedsubtitle="$subtitle"
            break
        done
    fi
fi

if [[ -n $selectedsubtitle ]] ; then
    grep_print "$selectedsubtitle"
    play "$selectedsubtitle"
elif [[ -n $subtitles ]] ; then
    grep_print "$subtitles"
    play "$subtitles"
else
    mpv "$garg0"
fi
