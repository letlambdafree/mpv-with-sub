#!/bin/bash

# mpv have three subtitle options (exact, fuzzy, all)

# this script has the following options
# 1. only one subtitle in the directory(recursive)
# 2. exact same subtitle with video name
# 3. fuzzy subtitle with video name
# 4. episode subtitle like S01E01, E01, Series.1.Part.1
# 5. in terminal, if subtitles exist, you can choose one or all or none

# if it failed to find a subtitle, it uses a mpv's original option

# the episode part of subtitle
# it may be added when emerge with another episode part
#
# S01E01
# S01.E01
# E01
# Series.1.Part.1

# two ways which to load subtitle files by mpv
# --sub-files="subtitle1:subtitle2:subtitle3"
#
# --sub-file="$subtitle1" --sub-file="$subtitle2" --sub-file="$subtitle3"

## TODO
#
#
#

if [[ ! -e $1 ]] ; then
    printf "\n"
    printf "\n mpv-with-sub requires a file as the first argument."
    printf "\n"
    exit 1
fi

PS3="Choose : "
SUBEXT="(srt|smi|ass|sub)"
videoname="${1##*/}"
videodir="${1%"$videoname"}"
videonameext="${1##*.}"
videosansname="${videoname%."$videonameext"}"
lowername=${videosansname,,}
ep1=$(expr "$lowername" : ".*\(s[0-9]\+\.\?e[0-9]\+\).*")
ep2=$(expr "$lowername" : ".*\(e[0-9]\+\).*")
ep3=$(expr "$lowername" : ".*\(series\.\?[0-9]\+\.\?part\.\?[0-9]\+\).*")

if [[ -n $ep1 ]] ; then ep="$ep1"
elif [[ -n $ep2 ]] ; then ep="$ep2"
elif [[ -n $ep3 ]] ; then ep="$ep3" ; fi

# printf "\n"
# printf "\n episode is $ep"
# printf "\n"

[[ -n $videodir ]] && cd "$videodir"

# for recursive directories
# probably need -2 deep level, otherwise so many files will be checked

shopt -s globstar
for file in **/* ; do
    lowerfile=${file,,}
    filenameext="${lowerfile##*.}"
    filesansname="${lowerfile%."$filenameext"}"
    if [[ $filenameext =~ $SUBEXT ]] ; then
        subcount=$(( subcount + 1 ))
        subfile="$file"
        if [[ $filesansname == $videosansname ]] ; then
            subtitles1="$file"
            # printf "\n"
            # printf "\n subtitles1 is $subtitles1"
            # printf "\n"
            break
        elif [[ $filesansname =~ $videosansname ]] ; then
            subtitles2="$file"
            # printf "\n"
            # printf "\n subtitles2 is $subtitles2"
            # printf "\n"
            break
        elif [[ -n "$ep" ]] ; then
            if [[ $filesansname =~ $ep ]] ; then
                if [[ -z $subtitles3 ]] ; then
                    subtitles3="$file"
                else
                    subtitles3="$subtitles1":"$file"
                fi
                # printf "\n"
                # printf "\n subtitles3 is $subtitles3"
                # printf "\n"
                # break
            elif [[ $filesansname =~ e0*"${ep#*e}" ]] ; then
                if [[ -z $subtitles4 ]] ; then
                    subtitles4="$file"
                else
                    subtitles4="$subtitles4":"$file"
                fi
                # printf "\n"
                # printf "\n subtitles4 is $subtitles4"
                # printf "\n"
                # break
            elif [[ $filesansname =~ e0*"${ep#*part\.}" ]] ; then
                if [[ -z $subtitles5 ]] ; then
                    subtitles5="$file"
                else
                    subtitles5="$subtitles3":"$file"
                fi
                # printf "\n"
                # printf "\n subtitles5 is $subtitles5"
                # printf "\n"
                # break
            fi
        fi
    fi
done

# only one subtitle > exact > fuzz > s01e01 > e01 > series.1.part.1
if [[ -n $subtitles1 ]] ; then subtitles="$subtitles1"
elif [[ -n $subtitles2 ]] ; then subtitles="$subtitles2"
elif [[ -n $subtitles3 ]] ; then subtitles="$subtitles3"
elif [[ -n $subtitles4 ]] ; then subtitles="$subtitles4"
elif [[ -n $subtitles5 ]] ; then subtitles="$subtitles5" ; fi

# only 1 subtitle in the directory
(( subcount == 1 )) && subtitles="$subfile"

# all subtitles, s01e01 + e01 + series.1.part.1
# subtitles="$subtitles1":"$subtitles2":"$subtitles3"

# printf "\n"
# printf "\n subtitles is $subtitles"
# printf "\n"

# when this script runs in terminal, select-loop activates.
# added "--dired" as $2 to distinguish between emacs-dired and terminal
if [[ $2 != "--dired" ]] ; then
    subtitlelines=$(sed s/:/\\n/g <<< $subtitles)
    # printf "\n"
    # printf "\n subtitlelines is $subtitlelines"
    # printf "\n"
    if (( $(wc -l <<< $subtitlelines) == 1 )) ; then
        selectedsubtitle="$subtitlelines"
    elif (( $(wc -l <<< $subtitlelines) > 1 )) ; then
        printf "\n"
        readarray -t arr_subtitles <<< "$subtitlelines"
        select subtitle in "${arr_subtitles[@]}" ; do
            if [[ $REPLY =~ ^("*"|"00")$ ]] ; then
                printf "\n"
                printf "\n You choose all subtitles. They'll be loaded."
                printf "\n To cycle through the available subtitles,"
                printf "\n press j and J."
                printf "\n"
                grep --color=auto . <<< "$subtitles"
                printf "\n"
                mpv --sub-files="$videodir""$subtitles" "$1"
                exit 0
            elif [[ $REPLY =~ ^("0")$ ]] ; then
                printf "\n"
                printf "\n You choose no subtitle."
                printf "\n It doesn't load any external subtitle."
                printf "\n"
                mpv --sub-auto=no "$1"
                exit 0
            fi
            selectedsubtitle="$subtitle"
            break
        done
    fi
fi

if [[ -n $selectedsubtitle ]] ; then
    printf "\n"
    grep --color=auto . <<< "$selectedsubtitle"
    printf "\n"
    mpv --sub-file="$videodir""$selectedsubtitle" "$1"
elif [[ -n $subtitles ]] ; then
    printf "\n"
    grep --color=auto . <<< "$subtitles"
    printf "\n"
    mpv --sub-files="$videodir""$subtitles" "$1"
else
    mpv "$1"
fi
